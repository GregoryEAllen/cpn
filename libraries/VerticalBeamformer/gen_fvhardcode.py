license = """
//=============================================================================
//	Computational Process Networks class library
//	Copyright (C) 1997-2006  Gregory E. Allen and The University of Texas
//
//	This library is free software; you can redistribute it and/or modify it
//	under the terms of the GNU Library General Public License as published
//	by the Free Software Foundation; either version 2 of the License, or
//	(at your option) any later version.
//
//	This library is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//	Library General Public License for more details.
//
//	The GNU Public License is available in the file LICENSE, or you
//	can write to the Free Software Foundation, Inc., 59 Temple Place -
//	Suite 330, Boston, MA 02111-1307, USA, or you can find it on the
//	World Wide Web at http://www.fsf.org.
//=============================================================================
/** \\file
  * \\author John Bridgman
  * This file is automatically generated by gen_fvhardcode.py.
  * This version of the fan vertical beamformer is highly unrolled.
  * To edit, make changes to the gen_fvhardcode.py and rerun jmake.
  */
"""
import sys

data = {
        'numElemsPerStave' : 12,
        'filterLen'        : 4,
        'numres'           : 3,
        'BLOCKSIZE'        : 4,
        'CVECSIZE'         : 2,
        'BLOCKSPFILT'      : 1,
        'VECPFILT'         : 2
        }

out = sys.stdout
out.write(license)
out.write('''
#include "FanVBeamformer.h"
#include "Assert.h"
#include <tmmintrin.h>
#include <complex>

using std::complex;

typedef __m128 vector; // float[4]
typedef __m128 cvector;
// complex<float>[2]

static inline cvector cmult(cvector a, cvector b) {
    /*
    cvector c, d;
    c = _mm_moveldup_ps(a);
    d = _mm_mul_ps(c, b);
    c = _mm_shuffle_ps(b, b, 0xb1);
    a = _mm_movehdup_ps(a);
    a = _mm_mul_ps(a, c);
    return _mm_addsub_ps(d, a);
    */
    return _mm_addsub_ps(_mm_mul_ps(_mm_moveldup_ps(a), b),
            _mm_mul_ps(_mm_movehdup_ps(a), _mm_shuffle_ps(b, b, 0xb1)));
}

static inline __m128i &as_m128i(cvector &a) { return *(__m128i*)&a; }

bool fvbf_sse_vector_hardcode_check(
    const complex<short> *indata,
    unsigned instride,
    unsigned numStaves,
    unsigned numSamples,
    float *filter,
    complex<float> *bbCorrect,
    unsigned numStaveTypes,
    unsigned numElemsPerStave,
    unsigned filterLen,
    FanVBeamformer::ResVec *rv,
    unsigned numres,
    unsigned &numOutSamples
) {
    return (%(filterLen)d == filterLen) && (%(numElemsPerStave)d == numElemsPerStave) && (%(numres)d == numres);
}

void fvbf_sse_vector_hardcode(
    const complex<short> *indata,
    unsigned instride,
    unsigned numStaves,
    unsigned numSamples,
    float *filter,
    complex<float> *bbCorrect,
    unsigned numStaveTypes,
    unsigned numElemsPerStave,
    unsigned filterLen,
    FanVBeamformer::ResVec *rv,
    unsigned numres,
    unsigned &numOutSamples
    )
{
''' % data)
out.write(''' 
    ASSERT(%(filterLen)d == filterLen);
    ASSERT(%(numElemsPerStave)d == numElemsPerStave);
    ASSERT(%(numres)d == numres);
    numOutSamples = numSamples - %(filterLen)d;

#ifdef _OPENMP
#pragma omp parallel for
#endif
    for (unsigned stave = 0; stave < numStaves; ++stave) {
        unsigned stavetype = stave %% numStaveTypes;
        const complex<short> *instave = &indata[stave * instride * %(numElemsPerStave)d];
        cvector s[%(numElemsPerStave)d][%(VECPFILT)d + %(CVECSIZE)d];''' % data)

for i in range(data['numElemsPerStave']):
    data['i'] = i
    for j in range(data['filterLen']/2):
        data['j'] = j + 2
        out.write( '''
        s[%(i)d][%(j)d] = _mm_setzero_ps();''' % data)

out.write('''
        for (unsigned samp = 0; samp < numOutSamples; samp += %(BLOCKSIZE)d) {''' % data)

# rearrange the memory accesses here!
# I can optimize cache misses this way!
if True:
    for i in range(data['numElemsPerStave']):
        data['i'] = i
        out.write('''
            {
                _mm_prefetch(&instave[%(i)d * instride + samp + %(BLOCKSIZE)d * 2], _MM_HINT_T0);
                __m128i e1 = *((__m128i*)&instave[%(i)d * instride + samp]);
                __m128i e2 = _mm_unpackhi_epi16(e1, e1);
                e1 = _mm_unpacklo_epi16(e1, e1);
                e1 = _mm_srai_epi32(e1, 16);
                s[%(i)d][1] = _mm_cvtepi32_ps(e1);
                e2 = _mm_srai_epi32(e2, 16);
                s[%(i)d][0] = _mm_cvtepi32_ps(e2);
            }''' % data)
else:
    for i in range(data['numElemsPerStave']):
        data['i'] = i
        out.write('''
            _mm_prefetch(&instave[%(i)d * instride + samp + %(BLOCKSIZE)d * 2], _MM_HINT_T0);
            as_m128i(s[%(i)d][0]) = *((__m128i*)&instave[%(i)d * instride + samp]);''' % data)

    for i in range(data['numElemsPerStave']):
        data['i'] = i
        out.write('''
            s[%(i)d][1] = _mm_cvtepi32_ps(_mm_srai_epi32(_mm_unpacklo_epi16(as_m128i(s[%(i)d][0]), as_m128i(s[%(i)d][0])), 16));
            s[%(i)d][0] = _mm_cvtepi32_ps(_mm_srai_epi32(_mm_unpackhi_epi16(as_m128i(s[%(i)d][0]), as_m128i(s[%(i)d][0])), 16));''' % data)



for res in range(data['numres']):
    data['res'] = res
    out.write('''
            {
                unsigned fan = rv[%(res)d].fan;
                complex<float> *outdata = rv[%(res)d].outdata;
                unsigned outstride = rv[%(res)d].outstride;
                float *fanfilter = &filter[fan * numStaveTypes * %(numElemsPerStave)d * %(filterLen)d + stavetype * %(numElemsPerStave)d * %(filterLen)d];
                complex<float> *fanbbCorrect = &bbCorrect[fan * numStaveTypes * %(numElemsPerStave)d + stavetype * %(numElemsPerStave)d];''' % data)
    out.write('''
                cvector stave_acc[%(CVECSIZE)d];''' % data)
    for i in range(data['CVECSIZE']):
        data['i'] = i
        out.write('''
                stave_acc[%(i)d] = _mm_setzero_ps();''' % data)
    for elem in range(data['numElemsPerStave']):
        data['elem'] = elem
        out.write('''
                {
                    float *filt = &fanfilter[%(elem)d * %(filterLen)d];
                    cvector elem_acc[%(CVECSIZE)d];''' % data)
        for i in range(data['CVECSIZE']):
            data['i'] = i
            out.write('''
                    elem_acc[%(i)d] = _mm_setzero_ps();''' % data)
        for fi in range(data['BLOCKSPFILT']):
            data['fi'] = fi
            out.write('''
                    {
                        vector coeffs = *((vector*)&filt[%(fi)d * %(BLOCKSIZE)d]);
                        cvector c = _mm_shuffle_ps(coeffs, coeffs, 0x00);
                        elem_acc[0] += s[%(elem)d][%(VECPFILT)d*%(fi)d + 1] * c;
                        elem_acc[1] += s[%(elem)d][%(VECPFILT)d*%(fi)d + 0] * c;
                        c = _mm_shuffle_ps(coeffs, coeffs, 0x55);
                        cvector temp = _mm_shuffle_ps(s[%(elem)d][%(VECPFILT)d*%(fi)d + 2], s[%(elem)d][%(VECPFILT)d*%(fi)d + 1], 0x4E);
                        elem_acc[0] += temp * c;
                        elem_acc[1] += _mm_shuffle_ps(s[%(elem)d][%(VECPFILT)d*%(fi)d + 1], s[%(elem)d][%(VECPFILT)d*%(fi)d + 0], 0x4E) * c;
                        c = _mm_shuffle_ps(coeffs, coeffs, 0xAA);
                        elem_acc[0] += s[%(elem)d][%(VECPFILT)d*%(fi)d + 2] * c;
                        elem_acc[1] += s[%(elem)d][%(VECPFILT)d*%(fi)d + 1] * c;
                        c = _mm_shuffle_ps(coeffs, coeffs, 0xFF);
                        elem_acc[0] += _mm_shuffle_ps(s[%(elem)d][%(VECPFILT)d*%(fi)d + 3], s[%(elem)d][%(VECPFILT)d*%(fi)d + 2], 0x4E) * c;
                        elem_acc[1] += temp * c;
                    }''' % data)
        out.write('''
                    complex<float> bbCor = fanbbCorrect[%(elem)d];
                    cvector cpx = _mm_setr_ps(bbCor.real(), bbCor.imag(), bbCor.real(), bbCor.imag());''' % data)
        for i in range(data['CVECSIZE']):
            data['i'] = i
            out.write('''
                    stave_acc[%(i)d] += cmult(elem_acc[%(i)d], cpx);''' % data)
        out.write('''
                }''')
    for i in range(data['CVECSIZE']):
        data['i'] = i
        if True:
            out.write('''
                _mm_prefetch(&outdata[stave *outstride + samp + (%(i)d + %(BLOCKSIZE)d)*%(CVECSIZE)d], _MM_HINT_T0);
                *((cvector*)&outdata[stave *outstride + samp + %(i)d*%(CVECSIZE)d]) = stave_acc[%(i)d];''' % data)
        else:
            out.write('''
                _mm_stream_ps(((float*)&outdata[stave *outstride + samp + %(i)d*%(CVECSIZE)d]), stave_acc[%(i)d]);''' % data)
    out.write('''
            }''')
for elem in range(data['numElemsPerStave']):
    for i in range(data['VECPFILT'], 0, -data['CVECSIZE']):
        for j in range(data['CVECSIZE']):
            out.write('''
            s[%d][%d] = s[%d][%d];''' % (elem, i + j, elem, i + j - data['CVECSIZE']))
out.write('''
        }
    }
}
''')


