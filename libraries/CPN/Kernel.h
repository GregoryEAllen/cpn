//=============================================================================
//	Computational Process Networks class library
//	Copyright (C) 1997-2006  Gregory E. Allen and The University of Texas
//
//	This library is free software; you can redistribute it and/or modify it
//	under the terms of the GNU Library General Public License as published
//	by the Free Software Foundation; either version 2 of the License, or
//	(at your option) any later version.
//
//	This library is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//	Library General Public License for more details.
//
//	The GNU Public License is available in the file LICENSE, or you
//	can write to the Free Software Foundation, Inc., 59 Temple Place -
//	Suite 330, Boston, MA 02111-1307, USA, or you can find it on the
//	World Wide Web at http://www.fsf.org.
//=============================================================================
/** \file
 * \brief Definition for the kernel object.
 * \author John Bridgman
 */

#ifndef CPN_KERNEL_H
#define CPN_KERNEL_H
#pragma once

#include "CPNCommon.h"
#include "KernelAttr.h"
#include "NodeAttr.h"
#include "QueueAttr.h"
#include "KernelBase.h"
#include "ReentrantLock.h"
#include "StatusHandler.h"
#include "Logger.h"
#include "Context.h"
#include "NodeLoader.h"
#include <string>
#include <map>
#include <vector>

class Pthread;

namespace CPN {

    /**
     * \brief The Kernel declaration.
     *
     * The purpose of the kernel object is to keep track
     * of all the queues and nodes on a particular host,
     * ensure that they are instantiated and destroyed
     * correctly and to provide a unified interface to
     * the user of the process network.
     */
    class CPN_API Kernel : public KernelBase {
        enum KernelStatus_t {
            INITIALIZED, RUNNING, TERMINATE, DONE
        };
    public:

        /**
         * Construct a new kernel object with the given attributes.
         * The Kernel starts processing immediately.
         */
        Kernel(const KernelAttr &kattr);
        ~Kernel();

        /**
         * Waits until the main loop terminates. Will not happen until
         * a terminate signal or Terminate is called.
         * Use WaitNodeTerminate if you wish to wait for the nodes to be
         * done.
         */
        void Wait();

        /**
         * For the kernel to terminate.
         * Returns immediately, use wait to wait
         * for completion.
         */
        void Terminate();

        /** \return true if Terminate has been called
         */
        bool IsTerminated();

        /** \brief Convenience method that checks IsTerminated and
         * if so throws a ShutdownException
         * \throw ShutdownException
         */
        void CheckTerminated();

        /**
         * Create a new node.
         *
         * The memory pointed to by argsize may be copied up to
         * argsize bytes into a location that the new node can access.
         *
         * \param attr The NodeAttr that describes the new node to create.
         * \return the new node's key
         * \throws KernelShutdownException if Wait completed or Terminate
         * has been called.
         */
        Key_t CreateNode(const NodeAttr &attr);

        /**
         * \brief Instantiating a function node.
         *
         * The idea of a function node is a simple function with minimal state.
         * A node is created and then the function is called with the given parameters.
         *
         * This list of prototypes was generated by FunctionNode.py
         * \@{
         */
        template<typename Function>
        Key_t CreateFunctionNode(const std::string &nodename, Function func);
        template<typename Function, typename Argument1>
        Key_t CreateFunctionNode(const std::string &nodename, Function func, Argument1 arg1);
        template<typename Function, typename Argument1, typename Argument2>
        Key_t CreateFunctionNode(const std::string &nodename, Function func, Argument1 arg1, Argument2 arg2);
        template<typename Function, typename Argument1, typename Argument2, typename Argument3>
        Key_t CreateFunctionNode(const std::string &nodename, Function func, Argument1 arg1, Argument2 arg2, Argument3 arg3);
        template<typename Function, typename Argument1, typename Argument2, typename Argument3, typename Argument4>
        Key_t CreateFunctionNode(const std::string &nodename, Function func, Argument1 arg1, Argument2 arg2, Argument3 arg3, Argument4 arg4);
        template<typename Function, typename Argument1, typename Argument2, typename Argument3, typename Argument4, typename Argument5>
        Key_t CreateFunctionNode(const std::string &nodename, Function func, Argument1 arg1, Argument2 arg2, Argument3 arg3, Argument4 arg4, Argument5 arg5);
        template<typename Function, typename Argument1, typename Argument2, typename Argument3, typename Argument4, typename Argument5, typename Argument6>
        Key_t CreateFunctionNode(const std::string &nodename, Function func, Argument1 arg1, Argument2 arg2, Argument3 arg3, Argument4 arg4, Argument5 arg5, Argument6 arg6);
        template<typename Function, typename Argument1, typename Argument2, typename Argument3, typename Argument4, typename Argument5, typename Argument6, typename Argument7>
        Key_t CreateFunctionNode(const std::string &nodename, Function func, Argument1 arg1, Argument2 arg2, Argument3 arg3, Argument4 arg4, Argument5 arg5, Argument6 arg6, Argument7 arg7);
        template<typename Function, typename Argument1, typename Argument2, typename Argument3, typename Argument4, typename Argument5, typename Argument6, typename Argument7, typename Argument8>
        Key_t CreateFunctionNode(const std::string &nodename, Function func, Argument1 arg1, Argument2 arg2, Argument3 arg3, Argument4 arg4, Argument5 arg5, Argument6 arg6, Argument7 arg7, Argument8 arg8);
        template<typename Function, typename Argument1, typename Argument2, typename Argument3, typename Argument4, typename Argument5, typename Argument6, typename Argument7, typename Argument8, typename Argument9>
        Key_t CreateFunctionNode(const std::string &nodename, Function func, Argument1 arg1, Argument2 arg2, Argument3 arg3, Argument4 arg4, Argument5 arg5, Argument6 arg6, Argument7 arg7, Argument8 arg8, Argument9 arg9);
        /**
         * \@}
         */

        /** \brief Create an external reader.
         *
         * A external reader is a handle for applications to use outside of the
         * network to input and output data
         * 
         * Note that a external reader can only be used on the kernel it is
         * created on.
         *
         * Implementation detail: External endpoints create a node internally
         * with the same name.  This means that they can be waited on with
         * WaitNodeStart and WaitNodeTerminate.  Also, WaitForAllNodeEnd will
         * not return until all external endpoints have been destroyed.
         * Additionally, external endpoint names must be unique across the
         * network and cannot share the same name as any node.
         *
         * \param name the name of the reader
         */
        void CreateExternalReader(const std::string &name);
        /** Dual of CreateExternalReader */
        void CreateExternalWriter(const std::string &name);

        /**
         * Get an OQueue for the given external writer.
         * \param name the name of the writer
         * \return A pointer to an object that oQueue will accept.
         */
        shared_ptr<QueueWriter> GetExternalOQueue(const std::string &name);

        /**
         * Get a IQueue for the given external reader.
         * \param name the name of the reader
         * \return A pointer to an object that IQueue will accept.
         */
        shared_ptr<QueueReader> GetExternalIQueue(const std::string &name);

        /**
         * Clean up the external endpoint.
         * Anybody waiting on it will then return.
         * Note that calling WaitForAllNodeEnd will block
         * until all external endpoints have died or Terminate is called.
         */
        void DestroyExternalEndpoint(const std::string &name);

        /**
         * Check for the existance of the given node. Returns
         * when it detects that the given node does not exist.
         * \param nodename the name of the node to wait for
         * \throws ShutdownException if the kernel has shutdown
         */
        void WaitNodeTerminate(const std::string &nodename);
        /** \brief Waits until there are no running nodes.
         */
        void WaitForAllNodeEnd();
        /** \brief Wait for the given node to start
         * \param nodename the name of the node to wait for
         */
        void WaitNodeStart(const std::string &nodename);

        /** \brief Create a new queue
         *
         * Note that the nodes for the queue must already exist.
         *
         * \param attr the attribute to use to create the queu
         * \see QueueAttr
         */
        void CreateQueue(const QueueAttr &attr);
       
        LoggerOutput *GetLogger() { return &logger; }

        /** 
         * \return the name of this kernel.
         */
        const std::string GetName() const { return kernelname; }

        /** \return the unique key for this kernel
         */
        Key_t GetKey() const { return hostkey; }

        /** \return the context this kernel is using
         */
        shared_ptr<Context> GetContext() const { return context; }

        /** \brief Called by the node in the cleanup routine.
         */
        void NodeTerminated(Key_t key);

        /**
         * These functions are called by the context to create things
         * remotely. Should not be called by anyone but the context!
         * \{
         */
        void NotifyTerminate();
        void RemoteCreateWriter(SimpleQueueAttr attr);
        void RemoteCreateReader(SimpleQueueAttr attr);
        void RemoteCreateQueue(SimpleQueueAttr attr);
        void RemoteCreateNode(NodeAttr attr);
        /**
         * \}
         */

        /** \brief Attempts to load the given dynamic library
         * and make the symbols inside available to be searched for
         * node types.
         * The library will be unloaded on distruction.
         * \param libname the library name and path
         */
        void LoadSharedLib(const std::string &libname) { nodeloader.LoadSharedLib(libname); }

        void LoadNodeList(const std::string &filename) { nodeloader.LoadNodeList(filename); }

        /** \brief Return a pointer to the node factory that produces the given
         * node type. May load a shared library to find the node factory.
         *
         * If there is no node factory available already, attempt to find
         * a function named "cpninitnodetype" and call it to get the factory.
         * If there is no function named this, then quiery the library loader
         * for a library with the name nodetype then try again. If all this
         * fails then throw a runtime_error exception.
         *
         * \param nodetype the type of the node
         * \return a node factory for the node type
         */
        NodeFactory *GetNodeFactory(const std::string &nodetype) { return nodeloader.GetFactory(nodetype); }

        /** \brief A function that lets others register node factories
         * \param factory the node factory
         */
        void RegisterNodeFactory(shared_ptr<NodeFactory> factory) { nodeloader.RegisterFactory(factory); }

        /** \brief Whether or not D4R should be used.
         * \return true or false (default true)
         */
        bool UseD4R();
        bool UseD4R(bool u);

        /** \brief Whether the queue should grow when
         * a threshold larger than the current max threshold is requested.
         * \return true or false (default true)
         */
        bool GrowQueueMaxThreshold();
        bool GrowQueueMaxThreshold(bool grow);

        /** \brief Whether the node should by default swallow the broken queue exceptions
         * or let them propigate as an error.
         * \return true or false
         */
        bool SwallowBrokenQueueExceptions();
        bool SwallowBrokenQueueExceptions(bool sbqe);

        /** \brief Calculate the new queue size when a queue needs to grow.
         * \return the new queue size
         */
        unsigned CalculateGrowSize(unsigned currentsize, unsigned request) {
            return context->CalculateGrowSize(currentsize, request);
        }

    private:
        // Not copyable
        Kernel(const Kernel&);
        Kernel &operator=(const Kernel&);

        void CreateExternalEndpoint(const std::string &name, bool iswriter);

        void CreateReaderEndpoint(const SimpleQueueAttr &attr);
        void CreateWriterEndpoint(const SimpleQueueAttr &attr);
        void CreateLocalQueue(const SimpleQueueAttr &attr);
        void InternalCreateNode(NodeAttr &nodeattr);
        void ClearGarbage();

        void *EntryPoint();

        void SendWakeup();

        // Function to be called from gdb
        void LogState();

        Sync::StatusHandler<KernelStatus_t> status;

        // Read only after construction or contain own synchronization,
        // no explicit synchronization required
        auto_ptr<Pthread> thread;
        const std::string kernelname;
        Key_t hostkey;
        Logger logger;
        shared_ptr<Context> context;
        auto_ptr<ConnectionServer> server;
        auto_ptr<RemoteQueueHolder> remotequeueholder;
        bool useremote;
        NodeLoader nodeloader;

        typedef std::map<Key_t, shared_ptr<PseudoNode> > NodeMap;
        typedef std::vector< shared_ptr<PseudoNode> > NodeList;

        // nodelock serializes access to nodemap
        Sync::ReentrantLock nodelock;
        Sync::ReentrantCondition nodecond;
        NodeMap nodemap;
        Sync::ReentrantLock garbagelock;
        NodeList garbagenodes;

        Sync::ReentrantLock datalock;
        bool useD4R;
        bool swallowbrokenqueue;
        bool growmaxthresh;
    };
}

#include "FunctionNode.h"

#endif
