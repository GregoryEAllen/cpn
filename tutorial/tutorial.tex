\documentclass{article}
\usepackage{fullpage}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{url}
\title{Tutorial on CPN}
\author{John Bridgman}
\begin{document}
\maketitle
\lstset{
    basicstyle=\small,
    language=c++,
    stringstyle=\ttfamily,
    tabsize=4
}

\section{Introduction}
This tutorial aims to give a basic walk through of how to use the Computational Process Network (CPN) library.
For most of the examples in this document the same toy example process network (PN) will be used.
This is so that you may see several different ways of implementing the same thing.
The example process network is a Fibonacci number generator.
The Fibonacci sequence can be described as the following recursive equation and initial values.
\begin{eqnarray}
F_n = F_{n-1} + F_{n-2}\\
F_0 = 1\\
F_1 = 1
\end{eqnarray}
This can be represented by a very simple PN and requires only two types of nodes.
The first type of node is a summing node that takes two inputs and one output.
The summing node takes one token from each input, sums them together and then enqueues the result
on the output.
We shall call the second type of node the cons node.
The cons node has an initial value, an input, and two identical outputs.
The cons node first outputs its initial value, then copies each token from the input to both outputs.
All the examples will use the external endpoint interface for the collection of the PN output.
The topology of the example PN is in Figure \ref{fig:fibinocci}.
Note that all arithmetic in the nodes is done using 64 bit unsigned integers and 12200160415121876738 is the largest
Fibonacci number that can be represented in 64 bits unsigned.
Asking for a maximum number any larger than this will result in overflow and incorrect results from the example.

\begin{figure}[htbp]
\centering
\includegraphics{fib}
\label{fig:fibinocci}
\caption{Process network to generate Fibonacci numbers}
\end{figure}

First, some introduction to supporting classes will be given in sections \ref{sec:variant} and \ref{sec:variantcpnloader}.
A discussion of how nodes are loaded is given in section \ref{sec:node loader}.
Then a discussion of how to create nodes with examples is in section \ref{sec:nodes}.
Finally, a discussion of how to distribute a PN is given in \ref{sec:distributing}.

\section{Kernel}

The main class used in CPN is the \verb|CPN::Kernel|.
The kernel is responsible for creating nodes and queues, maintaining the state of the
network, and cleaning up resources.
The kernel contains the node loader which it uses for creating nodes with type names.
See section \ref{sec:node loader} for detail of the node loader.
The kernel contains two ways of creating a new node.
There is also an interface for getting at queue endpoints outside the network by using
the external endpoint interface.
The kernel contains a context which it uses to store and query the configuration of the network
and talk to other kernels.
The details of the context are described in section \ref{sec:context}

\subsection{Construction}
The kernel takes a \verb|KernelAttr| parameter object in the constructor.
The only non optional parameter to the kernel is the name which is taken in the \verb|KernelAttr| constructor.
The setter methods are:
\begin{description}
\item[SetName] The name for the kernel.
\item[SetHostName] The hostname to bind to for making remote queue connections.
\item[SetServName] The service name or port number to bind to for making remote queue connections.
\item[UseD4R] Option to turn D4R off or on. Default is on.
\item[SetContext] The context for execution. If not given a local context is generated.
\item[SetRemoteEnabled] Force enable remote operations even when the context is not remote enabled and no host name or service name given.
\item[SwallowBrokenQueueExceptions] Whether to handle broken queue exceptions that propagate out of the node.
\item[GrowQueueMaxThreshold] Whether to grow the queue max threshold if a request for more than the max threshold is made.
\item[AddSharedLib] Add a shared library to the list of libraries to preload in the node loader for node lookup.
\item[AddNodeList] Add a node list to the node loader to parse for node lookup.
\end{description}

\subsection{Context}
\label{sec:context}

The context provides the mechanism through which the kernel keeps state about the network.
In order to distribute the network across multiple processes some shared state and message passing is required.
The context provides this shared state and message passing.
Under normal circumstances the user should have no need to call any method on the context directly.
The only reason the user needs to do anything with the context is when the process network is distributed.
The context class was specifically designed so that multiple implementations could be made.
Provided in the CPN library are two implementations.
The first implementation is \verb|LocalContext| which provides the context interface to one or more kernels
in the same process.
The second implementation is \verb|RemoteContext| which combined with the remote context server
gives a context object that provides state across multiple processes.
The \verb|RemoteContext| and server is built on top of two abstract base classes which provide everything
except the transportation medium.
The context was designed in this fashion to make it possible to implement custom state handling.
For example, it should be possible to implement a context that used a database and a synchronization service like ZooKeeper.

\subsection{Node Loader}
\label{sec:node loader}

When you ask the kernel to create a node by type name, it asks the node loader
for a node factory that can create a node of that type.
If there is a factory in that map it will return it.
You can explicitly add a factory to the map using \verb|RegisterNodeFactory|.
If no factory is found then there are several places the node loader will look to see if it can find one.
The first thing the node loader will do is search the executable for a symbol which is
the type name added to an identifier.
If a symbol with that name is found it is treated as a function that will return
a factory that can create nodes of that type.
If such a symbol is not found then the node loader will look if there is any node list that have
information about that type.
If so, it will look through it to see if there is a shared library that can be loaded to get a 
function that can supply a factory for that node type.
If all of these fail then the node loader throws an exception indicating that no factory could be found
for that node type.
Each kernel possesses its own node loader.

A node list is a file that has a very simple format.
The format is a directive followed by parameters then a semicolon.
Newlines, spaces, tabs, etc. are all considered white space and are collapsed unless they are inside of quotations or escaped.
The supported directives are ``lib'' and ``include''.
``lib'' has two parameters, the first being the type symbol name, and the second being a shared library object that can be loaded to get that symbol name.
The ``include'' directive treats each parameter as a file name that should be recursively loaded for more definitions.
Filenames with spaces and other special characters may be quoted.
The format also supports backslashes to escape any special meaning of the next character in unquoted strings and the \# character for single line comments.
See the file \url{libraries/CPN/NodeLoader.cc} for details.

One consequence of this loading scheme is that, in general, nodes will not have any referenced symbols in them.
This is not normally a problem except when one tries to put a node in a library and use a tool like \verb|jmake|.
\verb|jmake| collects objects into archives and then uses the linker to load the archive together.
The problem is the linker will prune out object files in archives with no references.
This causes objects in which we want to call symbols dynamically to not be linked into the executable.
So, when using tools like \verb|jmake|, a manual effort to ensure that there is a referenced symbol in the appropriate object
for all the nodes in archives needs to be made.
Also, if no nodes are statically linked efforts needs to be made to ensure that the linker does not prune out \verb|typeinfo| symbols that the nodes need in the CPN library.
On systems with the GNU linker this can be done by ensuring your tool uses the whole archive flag around the CPN library archives and the node archive files.
Even more linkers support the `-u' option which tells them to consider the given symbol name to be undefined and search through and load objects that define that symbol.
But using `-u' requires knowledge of the symbols that must be loaded and this is compiler and platform
specific.

\subsection{VariantCPNLoader}
\label{sec:variantcpnloader}

The \verb!VariantCPNLoader! is a class and a set of static methods that take a Variant object with data in a specific format and
use that data to call methods on a kernel object.
The \verb!VariantCPNLoader! also has a method for constructing a KernelAttr object from a Variant object.
An example of the loaders usage is given in the distributed section.
The \verb!VariantCPNLoader! has a validator that goes through the configuration and ensures that all required fields are present
and that there are no obvious errors like two nodes with the same name.

The CPNKernel application is an example of an application that will load up any set of derived nodes from a node library using
configuration files.
The CPNKernel application is in \url{apps/CPNKernel/main.cc}.

The configuration that the \verb!VariantCPNLoader! wants to see 
is a key value map at the base. There are nine keys that specify options for the kernel and three
that specify how to load the PN. The specification of what it wants to see is given in section \ref{sec:appendix b}.

\subsubsection{Variant}
\label{sec:variant}

The Variant class is a simple container that can represent a set of data structures.
What Variant can represent is directly mappable into the JavaScript Object Notation (JSON) specification and back again.
There are a set of classes and functions for parsing JSON to a Variant and back again.
There is also a set of classes and functions for parsing to an XML format and back again.
This means that an application that is setup right with Variant can accept both JSON and XML
input. More details on the JSON format can be found at \url{www.json.org}.
There is an example application in the \url{apps/XML-JSON} which reads in JSON to Variant and then outputs in our XML format
or reads in or XML format and outputs JSON.

\section{Nodes}
\label{sec:nodes}
There are two different ways to define or create a node.
The first way is to derive a node from \verb!CPN::NodeBase!. This method is more verbose but allows one to load
the node through the \verb!VariantCPNLoader!. The second way is by asking the kernel to create a function node.
A function node is a node which calls a function with a pointer to a \verb!CPN::NodeBase! and any additional supplied parameters.

\subsection{Derived Node Example}
\label{sec:derived node example}

In order to provide a derived node one must inherit from \verb!CPN::NodeBase!.
Also, if the standard node factory declaration macro is used the constructor must take a reference
to the \verb!CPN::Kernel! as the first parameter and a \verb|const| reference to the \verb!CPN::NodeAttr!
as the second parameter.
These are the parameters that the constructor for \verb!CPN::NodeBase! takes.
There is an additional macro for declaring a stateless node and factory together.
The declaration for the summing node is in Listing \ref{summer declaration}
The full source code for this example is in section \ref{derived source}.

To construct a derived node one must pass a \verb!CPN::NodeAttr! object to the kernel method \verb|CreateNode|.
The node attribute object requires a node name and a node type name as constructor arguments.
There is an overloaded version of \verb|CreateNode| which takes the name and type directly for when no additional
parameters are needed.
The main methods of interest on \verb|NodeAttr| are \verb!NodeAttr::SetParam! and \verb!NodeAttr::SetKernel!.
The \verb!NodeAttr::SetParam! method allow the passing of
string parameters to the node.
The parameters are given to the node as a string to string mapping and are available through the
\verb|NodeBase::GetParam| family of methods.
The \verb!NodeAttr::SetKernel! is used to tell the kernel which kernel we want the node to be created on
when distributing the process network.
See section \ref{sec:distributing} for details.
To construct a node in this fashion the node loader must be able to find the node factory.
See section \ref{sec:node loader} for more details on how the node loader finds factories.

\begin{lstlisting}[caption=Declaration for the summing node,label=summer declaration]
class Summer : public NodeBase {
public:
    Summer(Kernel &ker, const NodeAttr &attr)
    : NodeBase(ker, attr) {}
private:
    void Process();
};
\end{lstlisting}

Note that we could have used the macro \verb|CPN_DECLARE_NODE_AND_FACTORY| here, but we want to show
how to write a node declaration out. The cons node uses this macro.
\verb!CPN::NodeBase! has one purely virtual method with the signature \verb!void Process()!.
This method will be called in a separate thread to execute the node.
When this method returns the kernel assumes the node has finished and starts freeing resources.
All the constructor does here is pass its parameters to NodeBase.

Note that the node does not officially exist until the constructor returns.
So, we cannot call \verb|GetIQueue| or \verb|GetOQueue| in the constructor because
a node must exist before a queue can be created for it and the node does not exist until
after the constructor returns.

When the kernel starts the node, the \verb!Process()! method is called in a separate thread.
The code for the summing node's \verb!Process()! method is in Listing \ref{summer process}.

\begin{lstlisting}[caption=Summing node process declaration,label=summer process]
void Summer::Process() {
    IQueue<uint64_t> in_a = GetIQueue("A");
    IQueue<uint64_t> in_b = GetIQueue("B");
    OQueue<uint64_t> out = GetOQueue("C");
    while (true) {
        uint64_t val_a, val_b, sum;
        if (!in_a.Dequeue(&val_a, 1)) break;
        if (!in_b.Dequeue(&val_b, 1)) break;
        sum = val_a + val_b;
        out.Enqueue(&sum, 1);
    }
}
\end{lstlisting}

Note that the raw underlying queue is typeless and simply does a blind bit wise copy of the data.
This means that only plain old data (POD) types can be sent over the queues in CPN.
The \verb!CPN::IQueue<T>! and \verb!CPN::OQueue<T>! provide
type checking and type coercion for the raw queue interface.
Each queue has associated with it a string identifying the type that that queue should handle.
\verb|IQueue| and \verb|OQueue| check this string and throw an exception on assignment if the types do not match.

First, the summer node gets all its input endpoints and places them in \verb|IQueue|s.
Next, the node gets the output port and places it in an \verb|OQueue|.
Then it reads from all its inputs, sum them and enqueues the result.
Note that the \verb!IQueue<T>::Dequeue(T *, unsigned)! function will return
\verb!false! when the other end of the queue disconnects.
There are two ways to disconnect. The first is to call \verb!Release! on the queue endpoint
and the second is to return from \verb!Process()!.
Trying to enqueue to a disconnected queue will result in a \verb!CPN::BrokenQueueException!
being thrown.

The very final thing in the file is the node factory declaration.
This uses the macro \newline\verb!CPN_DECLARE_NODE_FACTORY(class, typename)!.
This macro defines a node factory and then the special symbol that the node loader uses to look up
the node type at run time.
Note that the type name must be a valid symbol (limited to alphanumeric and underscore).
Usually it is the same as the node class name.
There is an additional macro \verb!CPN_DECLARE_NODE_AND_FACTORY(class, typename)! which
declares both the node and the factory.
This macro is convenient for when the node has no state.
We could have used this macro for the summing node and the cons node uses this macro.
Full code for the summing node is available in Listing \ref{lst:summer}.
The cons nodes are very similar. Full code for the cons node is in Listing \ref{lst:cons}.

Now on to instantiating and running the nodes.
Full code for the main function to run this example is in Listing \ref{lst:dn main}.
First we have to create a \verb!CPN::Kernel!.
For this example we will create the kernel on the stack.
The constructor requires a \verb!CPN::KernelAttr! object as a parameter object.
The kernel attribute object only has one required parameter and that is a name for the kernel.
We set two flags on the \verb|KernelAttr| object.
The first is to not use the D4R algorithm.
The second is to swallow broken queue exceptions.
By default the broken queue exceptions are left unhandled and end up with a call to \verb!std::terminate! ending in application termination.

\begin{lstlisting}
    Kernel kernel(KernelAttr("kernel")
        .UseD4R(false)
        .SwallowBrokenQueueExceptions(true));
\end{lstlisting}

Next, the nodes need to be created. It is important to notice that the nodes for a queue must exist before
the queue can be created.
Attribute objects can be reused as their contents are copied in the function.

\begin{lstlisting}
    kernel.CreateNode("summer", "Summer");
    NodeAttr nattr("Cons 1", "Cons");
    nattr.SetParam("initial", 1).SetParam("num outputs", 2);
    kernel.CreateNode(nattr);
    nattr.SetName("Cons 2");
    kernel.CreateNode(nattr);
    kernel.CreateExternalReader("result");
\end{lstlisting}

Then the queues can be created.

\begin{lstlisting}
    QueueAttr qattr(2*sizeof(uint64_t), sizeof(uint64_t));
    qattr.SetDatatype<uint64_t>();
    qattr.SetWriter("Cons 1", "out0").SetReader("summer", "A");
    kernel.CreateQueue(qattr);
    qattr.SetWriter("Cons 2", "out0").SetReader("summer", "B");
    kernel.CreateQueue(qattr);
    qattr.SetWriter("summer", "C").SetReader("Cons 1", "in");
    kernel.CreateQueue(qattr);
    qattr.SetWriter("Cons 1", "out1").SetReader("Cons 2", "in");
    kernel.CreateQueue(qattr);
    qattr.SetWriter("Cons 2", "out1").SetExternalReader("result");
    kernel.CreateQueue(qattr);
\end{lstlisting}

Finally, use the created external reader to gather the results.
Notice that we must explicitly destroy the external reader.
When the endpoint is released the queues on the other nodes get shut down, causing all the nodes to exit.
We set the swallow broken queue exceptions flag on the kernel above so that we would obtain this behavior.

\begin{lstlisting}
    IQueue<uint64_t> result = kernel.GetExternalIQueue("result");
    uint64_t value;
    do {
        result.Dequeue(&value, 1);
        std::cout << "- " << value << std::endl;
    } while (value < max_fib);
    result.Release();
    kernel.DestroyExternalEndpoint("result");
    kernel.WaitForAllNodes();
\end{lstlisting}

This gathering of results gives a simple example of how to use the external endpoints.
The external endpoints were added for the explicit reason of having outside code that needed
to act as a source or sink into the PN.
For example if you were using CPN as processing glue between two independent subsystems that both used
callbacks.
You could supply external endpoints to each callback and the two systems could
then work as sources and sinks in the PN.

\subsection{Function Node Example}
\label{sec:function node example}

Function nodes are useful when you want to have a simple one off node or don't need auto
loading.
Function nodes cannot be automatically loaded by the node loader.
This means that the VariantCPNLoader can't specify these nodes and they must be created manually.
Using function nodes can make a simple PN much easier to write.
You can still use the VariantCPNLoader to load the queue descriptions once the nodes are created.
The kernel has a set of overloaded template functions which take as the first parameter the new node
name, the second parameter is a function object to call, and optional additional arguments are captured and
passed to the function object.

To create the Fibonacci generator we have been discussing we need two nodes. This time we will use
functions for the nodes. The functions should take as the first argument a pointer to a \verb!CPN::NodeBase!.
The summer and cons node functions are defined as:

\begin{lstlisting}
static void Summer(NodeBase *node) {
    IQueue<uint64_t> in_a = node->GetIQueue("A");
    IQueue<uint64_t> in_b = node->GetIQueue("B");
    OQueue<uint64_t> out = node->GetOQueue("C");
    while (true) {
        uint64_t val_a, val_b, sum;
        if (!in_a.Dequeue(&val_a, 1)) break;
        if (!in_b.Dequeue(&val_b, 1)) break;
        sum = val_a + val_b;
        out.Enqueue(&sum, 1);
    }
}

static void Cons(NodeBase *node, uint64_t initial) {
    IQueue<uint64_t> in = node->GetIQueue("in");
    OQueue<uint64_t> out_a = node->GetOQueue("out0");
    OQueue<uint64_t> out_b = node->GetOQueue("out1");
    uint64_t current = initial;
    while (true) {
        out_a.Enqueue(&current, 1);
        out_b.Enqueue(&current, 1);
        if (!in.Dequeue(&current, 1)) break;
    }
}
\end{lstlisting}

Then to create the nodes we have:
\begin{lstlisting}
    kernel.CreateFunctionNode("summer", Summer);
    kernel.CreateFunctionNode("Cons 1", Cons, 1);
    kernel.CreateFunctionNode("Cons 2", Cons, 1);
    kernel.CreateExternalReader("result");
\end{lstlisting}
Everything else is the same as the derived node example.
The full example is in Listing \ref{lst:function node}.

\section{Distributing}
\label{sec:distributing}

This section assumes you have read the sections on \verb!Variant! and the \verb!VariantCPNLoader!.
In order to use the distributed features you need to have setup a remote context daemon.
A simple daemon implementation is in \url{apps/RemoteContext}.
When setting up the kernels you then have to use a remote context instance in the kernel attribute and possibly set the host name in the attribute.
Then when creating nodes you specify which kernel that node should be created on using the \verb!NodeAttr::SetKernel! method.
If everything works right, then that's all the additional things that must be done over running on a single kernel.
You of course have to ensure that every process possesses the node definitions that you try to load on it.
The usual method of ensuring this used in the examples so far is to make all processes the same executable and the difference
in behavior between them is decided by command line arguments and configuration files.

Next is the example of the Fibonacci number generator using the distributed features of CPN.
The summing and cons node are the same as in the first example on derived nodes and are symbolic links in the code directory.
This example also uses the \verb!VariantCPNLoader! to load the PN.
A special note that the listings in this section will omit much of the error checking.
Full error checking is included in the full listing in Listing \ref{lst:distributed}.

Let us look at the configuration files in Listings \ref{lst:common_defs}, \ref{lst:pn_def} and \ref{lst:nodemap}.
Notice that the configuration is split between multiple files.
This allows for certain parts of the configuration to be reused and combined in different ways.
Many times just a small part of the configuration needs to be different for each kernel.
Once the distributed example is built there is a option `-C' which causes the program
to load all configuration data then print that data out in JSON format and exit.
This can give a good idea of what the loader is doing and you can see how the command line options change
what goes into the loader.

Now a description of the program.
The first thing the program does is setup some default values and instantiates a VariantCPNLoader and calls it \verb|loader|.

\begin{lstlisting}
    uint64_t max_fib = 100;
    bool load_config = true;
    bool print_config = false;
    VariantCPNLoader loader;
\end{lstlisting}

Then the command line options are parsed. Several of the command line options are required.
This example will not run correctly without them.
The validator should catch any options that are left out that are absolutely required.
For example, the \verb!--name! option must be specified.
Use the \verb!run! script to run this example.
The \verb!run! script provided in the code directory runs the remote context daemon and then
runs each of the kernels with the correct parameters.
Notice that any configuration files that should be loaded are done when parsing the command line options.
The configurations are loaded in the order provided and any duplicate entries override previous entries.

Now that we finished loading the configuration comes the easy part, running the configuration.
First we get the loader to create a \verb!KernelAttr! for us.
The loader knows about the two default context types and automatically creates a remote context
if a context host and port are specified.
\begin{lstlisting}
    Kernel kernel(loader.GetKernelAttr());
\end{lstlisting}
Then if we are the loading kernel we will first create a pseudo node to get the results and then
load up the configuration.
\begin{lstlisting}
    if (load_config) {
        kernel.CreateExternalReader("result");
    }
    loader.Setup(&kernel);
\end{lstlisting}
Once the configuration is done, we read out the results and clean up.
\begin{lstlisting}{}
    if (load_config) {
        QueueAttr qattr(2*sizeof(uint64_t), sizeof(uint64_t));
        qattr.SetWriter("Cons 2", "out1");
        qattr.SetExternalReader("result");
        kernel.CreateQueue(qattr);

        IQueue<uint64_t> result = kernel.GetExternalIQueue("result");
        uint64_t value;
        do {
            result.Dequeue(&value, 1);
            std::cout << "- " << value << std::endl;
        } while (value < max_fib);
        kernel.DestroyExternalEndpoint("result");
        kernel.WaitForAllNodes();
    } else {
        kernel.Wait();
    }
\end{lstlisting}
Notice that the kernels not reading out the result wait for the network to terminate.
This ensures that the other kernels will stick around until we are done with the PN.

\section{Kahn Example}

Also included with the code for this tutorial is an example usage of CPN to create
the process network that Kahn used in his paper.

\section{Appendix A}

\subsection{Derived Node}
\label{derived source}
\lstinputlisting[caption=The Summing Node,label=lst:summer]{code/derived_node/Fib_Summer.cc}
\lstinputlisting[caption=The Cons Node,label=lst:cons]{code/derived_node/Fib_Cons.cc}
\lstinputlisting[caption=Instantiating the declared nodes and running them,label=lst:dn main]{code/derived_node/main.cc}
\subsection{Function Node}
\lstinputlisting[caption=Example of function nodes,label=lst:function node]{code/function_node/main.cc}
\subsection{Distributed}
\lstinputlisting[caption=Example of the main routine for distributing the PN,label=lst:distributed]{code/distributed/main.cc}
\subsection{Distributed  Configuration Files}
\lstinputlisting[caption=Common definitions between kernels,label=lst:common_defs]{code/distributed/common_defs.json}
\lstinputlisting[caption=Process Network Definition,label=lst:pn_def]{code/distributed/pn_def.json}
\lstinputlisting[caption=Node mapping,label=lst:nodemap]{code/distributed/nodemap.json}

\section{Appendix B}
\label{sec:appendix b}

Kernel loader data formats.

The nine options for the kernel are:
\begin{description}
\item[``name''] The name that the kernel will use (required).
\item[``host''] The host name that the kernel will use to listen on (CPN uses POSIX \verb|getaddrinfo| for 
address lookup and as such supports any host name or port name format that \verb|getaddrinfo| can turn into a \verb|sockaddr| struct) (optional).
\item[``port''] The port number or name that the kernel will use to listen on (optional).
\item[``d4r''] Whether to use the D4R algorithm or not (optional, default true).
\item[``swallow-broken-queue-exceptions''] Whether to swallow the BrokenQueueException that can be emitted from an enqueue (optional, default false).
\item[``grow-queue-max-threshold''] Whether to automatically grow the queue if a larger threshold is asked for than the queue can handle (optional, default true)
\item[``libs''] A list of shared libraries that contain node definitions that the node loader should load up immediately.
\item[``liblist''] A list of node list files that contain information about where to find the shared libraries for nodes that are not statically linked in or manually loaded.
\item[``context''] A sub-map that describes options for what kind of context to load and what options on the context to set. Those options are:
\begin{description}
\item[``host''] What host name the context daemon is listening on (optional, if present ``port'' must also be specified, else the local context implementation will be used).
\item[``port''] What port number or name the context daemon is listening on.
\item[``loglevel''] Specify the logging level for the internal CPN logger. This is mainly used for debugging the internals of the CPN library.
\end{description}
\end{description}

The three keys that specify how to load the PN are:
\begin{description}
\item[``nodes''] A list of node definitions.
\item[``queues''] A list of queue definitions.
\item[``nodemap''] A key value map with node names as keys and the kernel name which that node should be run on as values.
\end{description}

A node definition is a map with the following fields:
\begin{description}
\item[``name''] The unique name for the node (required).
\item[``type''] The type name of this node (required).
\item[``param''] Parameters to pass to this node (optional). If parameters is a Variant then it will be serialized as JSON.
\item[``kernel''] The name of the kernel that this node should be loaded on (optional). The nodemap overrides this option.
\end{description}

The queue definition is a map with the following fields:
\begin{description}
\item[``size''] The size in bytes of this queue (required).
\item[``threshold''] The size in bytes of the threshold (required).
\item[``readernode''] The name of the node that will read from this queue (required).
\item[``readerport''] The port name that the reader node will use (required).
\item[``writernode''] The name of the node that will write to this queue (required).
\item[``writerport''] The port name that the writer node will use (required).
\item[``type''] The type of queue, either ``threshold'' or ``default'' (optional, default is ``default'').
\item[``datatype''] A string that specifies the data type for the queue (optional, default ``void''). 
Some valid types are ``void'', and the various types names defined in ``stdint.h'' like ``int32\_t'' as well as ``float'', ``double'', and ``complex$<$T$>$'' where ``T'' is any of the previous types.
\item[``numchannels''] The number of channels for this queue (optional, default 1).
\item[``alpha''] A parameter used only by the remote queue allowing one to specify how much space to split between the two sides (optional, default 0.5).
\end{description}



\end{document}
