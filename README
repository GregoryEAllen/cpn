
To build the unit tests cppunit must be installed and pkg-config must know how
to get its compiler flags.  All the tests are in the test directory.  All tests
dealing with the CPN library are in cpntest. Some of the other libraries have a test directory.
The XML features require libxml++.

Dependent libraries:
    * cppunit
    * libxml++
    * fftw

Seive of Eratosthenes

There are two versions of this, the first is called SimpleSieve and the second
is called ThresholdSieve.  To run these go either
apps/SieveOfEratosthenes/SimpleSeive or /ThresholdSieve and execute jmake. Then run
the resulting executable with the -h option to get specific options.

Random Instruction

There are two ways to run the random instruction test.
The first is all in one process. Go to apps/RandomInstruction and jmake.
Then run with -h to get a list of options.

The second one is on multiple processes and requires more setup.
First build apps/RemoteRandomInstruction then build apps/RemoteDatabase.
Then create a config file for the RemoteRandomInstruction, (the -h
option prints out a description of what the config is supposed to look like.
As well, there is an example config file in that directory).
Now run the RemoteDatabase with the listening host and port set in the config.
Then run each of the RemoteRandomInstruction with parameters of config then
the name, database host and database port.

For the given example config it would be:
Run on zeus: RemoteDatabase zeus 12345
Run: RemoteRandomInstruction configk2n100i100 kone zeus 12345
Run: RemoteRandomInstruction configk2n100i100 ktwo zeus 12345


Added features:
    * D4R
    * Pseudo nodes
    * Functional nodes
    * Beamformer case study
    * General cleanup and restructure of libraries
    * Most of the remote queue stuff has been rewritten
    * Fixed several issues in PthreadLib
    * Most of the queue stuff has been rewritten
    * Added the ability to load a network from a Variant config
    * Added a loader from XML to Variant
    * Added node library
    * Made node loading be through symbol name lookup
    * Updated sieve case studies

Known issues:
    * Possible for D4R implementation to transmit a tag while unblocking, this
      can cause D4R to think a deadlock occures when there is no deadlock. I
      have only seen this happen when running tests for hours on a fully loaded
      box.


About pseudo nodes

Pseudo nodes are a special handle to a node which doesn't have a thread.  This
is useful for the case where you want to input or output data to the network of
nodes.  For example, instantiate some network of nodes, then create two speudo
nodes to be input and output.  Then this allows for the application to grab
endpoints for those pseudo nodes outside of a node for putting data in and out.
One has to be careful though as all the same rules apply for determinism and
deadlock. The idea behind this was that CPN could be used in a larger
application where CPN is just a library used to compute some intermediate value
for the application.  One of the design goals in mind while writing CPN was
that it should be useable in as many types of situations as possible.

Example:

CPN::Key_t pnodekey = kernel.CreatePseudoNode("Pseudo node name");
... generate queues...
CPN::WriteQueueAdapter<int> out = kernel.GetPseudoWriter(pnodekey, "endpoint name");
while (data) {
    ...
    out.Enqueue(...);
    ...
}
out.Release();
...

kernel.DestroyPseudoNode(pnodekey);


About Functional Nodes

This is very similar to pseudo nodes. These are special nodes that can be
created by passing a function or function object to the kernel. It is setup
with templates to allow for the passing of up to 9 parameters to a function
node.  The idea here is that sometimes one wants a simple node where writing
all the machinary for a full blown node would be overkill.  This feature is
used in the tests in several places where writing a full node would have been
painfully verbose.

Example:

void testnode(CPN::NodeBase *node, std::string endpoint) {
    CPN::QueueReaderAdapter<int> in = node->GetReader(endpoint);
    ... read from in
}

...
in setup do
...
kernel.CreateFunctionNode("node name", testnode, std::string("endpoint name"));


